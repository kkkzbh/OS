\chapter*{前言}
\addcontentsline{toc}{chapter}{前言}

\section*{项目概览}
这个项目从“通电→引导→内核→用户态”全链路拆解一套 32 位内核：启动加载代码放在 \codeinline{boot/}，核心设施位于 \codeinline{kernel/}，驱动与外设抽象集中在 \codeinline{device/}。各章直接引用仓库源码，便于在叙述与代码之间对照阅读。

\section*{章节导览}
每一章都对应开发流水线中的一个里程碑。

\begin{description}
  \item[第 1 章 Boot] 从 BIOS、MBR 到保护模式切换，覆盖 GDT、分页开启以及高半区映射，奠定“内核如何抵达内存”的起点。
  \item[第 2 章 基础输出] 构建最小的 \codeinline{putchar}/\codeinline{printf} 支撑，让后续调试与断言输出有统一通道。
  \item[第 3 章 中断与异常] 讲解 IDT、PIC/APIC、陷阱门与异常分发，配套完整的中断框架与栈切换流程。
  \item[第 4 章 内存管理] 介绍物理页分配器、内核页表布局与内存映射策略，解释为何需要分层抽象。
  \item[第 5 章 线程与调度] 从上下文切换、调度算法到同步原语，展示自研线程库如何在裸机上运转。
  \item[第 6 章 设备与 I/O] 收拢串口、定时器、IDE 等驱动，以及统一的总线/中断抽象，便于新增外设。
  \item[第 7 章 用户态支撑] 建立特权级切换、系统调用入口与进程镜像装载，铺设用户程序运行环境。
  \item[第 8 章 系统库] 提供最小化 C/C++ 运行时与常用容器/字符串实现，兼顾 freestanding 环境的可重用性。
  \item[第 9 章 磁盘与块设备] 解释磁盘布局（MBR LBA0、Loader LBA2、Kernel LBA9 起步）、缓存策略与 IDE 访问路径。
  \item[第 10 章 文件系统] 设计 VFS 层、inode/目录管理与数据一致性策略，把磁盘抽象成可用 API。
  \item[第 11 章 系统交互] 汇总 shell、调试接口与系统服务，展示内核如何对外暴露可操作的交互面。
\end{description}

\section*{环境与工具链}
仓库配置为下列版本/依赖：

\begin{description}
  \item[主机基础] 64 位 Linux 环境，并安装 \codeinline{gcc-multilib}、\codeinline{nasm} 等基础工具。
  \item[C/C++ 标准] C23 + \codeinline{C++26}（由顶层 \codeinline{CMakeLists.txt} 的 \codeinline{set(CMAKE_C_STANDARD 23)} 与 \codeinline{set(CMAKE_CXX_STANDARD 26)} 强制）。
  \item[编译器] GCC 15.1.0（含 32 位目标支持，建议以 \codeinline{i386-elf-gcc} 或自带 multilib 方式调用）。
  \item[CMake] 4.0.1 及以上；推荐使用 Ninja 生成器，仓库默认构建目录为 \codeinline{cmake-build-debug}。
  \item[Bochs 仿真] 可直接执行 \codeinline{bochs -qf bochsrc.disk}；如需图形前端或节点版，可按各自安装路径替换命令。
  \item[调试] GDB 13+ 可通过 \codeinline{bochsrc-gdb.disk} + \codeinline{target remote :1234} 连入；串口输出与 Bochs 日志会保存在仓库根目录。
\end{description}

\section*{闲言}
该OS更多的是学习时对项目的复现，代码基本都是一行行手敲的，但是自己也进行了一些改变，诸如尝试使用现代C++语言而不是C语言，使用CMake构建而非MakeFile，目前内核部分基本完善，外层的shell和用户程序还差一点东西。

OS为单核32位，利用Bochs做硬件仿真，有boot引导程序; 中断只实现了时钟，键盘，硬盘; 内存分配基于arena，把一个页(4KB)分割为多个2的幂，串在多个代表某2的幂的内存链表上，然后找最满足最优的那个块，如果大于4KB则直接按多少页分配出去; 线程与进程调度使用时间片轮转调度，在一个进程线程队列上，目前基本是先来先服务，但是PCB存在优先级字段，但没有被使用，存在紧急的线程的处理是直接插到队列头，非抢占式; 同步实现了信号量工具，以及互斥量(信号量初值为1的封装); 实现了比C语言的printf更强大的泛型print，保证了类型安全，也实现了很多供内核和用户程序使用的标准库设施; 硬盘采用两块盘，一块裸盘存内核，一块带有文件系统和格式化分区的盘，文件系统基本完善，支持read, write调用读写文件; 支持一个简易的shell，可以使用ls, cd, ps, pwd等简易命令，另外还支持在shell上使用./a执行可执行程序(用户程序)，具体方式是，借助windows宿主机的编辑器编写.cpp代码，借助windows的gcc编译器将代码编译为二进制可执行程序，然后写入到裸盘，在内核里直接读写裸盘读出二进制程序，利用write写到文件系统盘(因为裸盘可以直接读写硬盘，而操作文件系统盘只能用write来保证不破坏硬盘的文件系统)，然后就可以在shell上通过ls看到可执行程序，然后去执行了。未来如果可以在内核集成编辑器以及编译器支持，则可以直接在shell中编写代码然后利用编译器编译执行。

这里按目录简单梳理一下仓库结构和各自职责。

\begin{description}
  \item[\codeinline{boot/}] 引导相关代码与头文件，包含 MBR、Loader 以及进入保护模式前后的早期初始化逻辑。
  \item[\codeinline{kernel/}] 内核主体代码：\codeinline{include/} 存放公共头文件，\codeinline{src/} 提供通用基础设施；\codeinline{module/filesystem/} 实现文件系统，\codeinline{module/memory/} 负责物理/虚拟内存管理与分配器，\codeinline{module/thread/} 提供线程、进程与调度框架，\codeinline{module/std/} 实现“标准库”与常用工具，\codeinline{module/shell/} 实现内核 shell 与命令解释，\codeinline{module/program/} 负责用户程序装载与运行时支撑，\codeinline{module/user/} 衔接用户态与系统调用接口；\codeinline{test/} 放置内核内的测试用例。
  \item[\codeinline{device/}] 设备抽象与驱动实现：\codeinline{console/} 提供文本控制台与屏幕输出，\codeinline{keyboard/} 处理键盘中断与扫描码解析，\codeinline{time/} 提供时钟中断与节拍计时，\codeinline{ide/} 实现 IDE 硬盘驱动与块设备接口，\codeinline{ioqueue/} 提供设备 I/O 队列与缓冲原语，\codeinline{include/} 则汇总设备相关公共头文件。
  \item[\codeinline{CMakeLists.txt}] 顶层构建脚本，统一定义 32 位交叉编译选项、目标布局、磁盘镜像写入规则等。
  \item[\codeinline{bochsrc.disk}] Bochs 仿真配置文件，描述磁盘映像挂载方式与调试端口，其中 \codeinline{bochsrc-gdb.disk} 预置了远程 GDB 调试配置。
  \item[\codeinline{hd64M.img}] 小容量裸盘镜像，主要用于存放 MBR、Loader 和内核本身，便于直接按 LBA 读写。
  \item[\codeinline{hd80M.img}] 带有文件系统与分区布局的磁盘镜像，用来承载用户程序与数据文件，是 shell 看到的“逻辑磁盘”。
\end{description}
