\chapter{引导程序}

本章围绕仓库中 \mintinline{text}{boot/} 目录的实现展开，梳理从主引导记录（MBR）到自制 Loader 的完整流程：磁盘布局、实模式初始化、LBA 读盘、内存探测、进入保护模式以及为内核准备分页环境。重点解释高半区（0xC0000000 以上）执行所需的指令与数据布局。

\section{磁盘布局与常量约定}

引导阶段的内存与磁盘布局通过 \mintinline{text}{boot/include/boot.inc} 统一声明，涵盖 Loader 与内核的加载地址、分页用到的物理页框等常量：

\begin{table}[h]
    \centering
    \begin{tabular}{lll}
        \toprule
        标识符 & 含义 & 数值/扇区号 \\
        \midrule
        \mintinline{text}{LOADER_BASE_ADDR} & Loader 复制到内存的基址 & 0x900 (实模式可用低端内存) \\
        \mintinline{text}{LOADER_START_SECTOR} & Loader 在磁盘的起始 LBA 扇区 & 0x2 \\
        \mintinline{text}{KERNEL_BIN_BASE_ADDR} & 保护模式下临时存放 \mintinline{text}{kernel.bin} 的内存地址 & 0x70000 \\
        \mintinline{text}{KERNEL_START_SECTOR} & 内核镜像的磁盘起始扇区 & 0x9 \\
        \mintinline{text}{PAGE_DIR_TABLE_POS} & 建立分页结构使用的物理地址 & 0x0010\,0000 (1MB) \\
        \mintinline{text}{KERNEL_ENTRY_POINT} & 最终跳转到的内核虚拟地址入口 & 0xC0001500 \\
        \bottomrule
    \end{tabular}
    \caption{引导阶段关键常量，节选自 \mintinline{text}{boot/include/boot.inc}}
\end{table}

这些约定决定了后续章节中的地址推导：MBR 负责把 Loader 复制到 0x900，Loader 则在保护模式下把内核镜像搬运至 0x70000，并在分页开启后跳到 0xC0001500。

\section{MBR：实模式初始化与 Loader 载入}

自制 MBR 在 BIOS 把扇区装载到 0x7C00 后开始执行。它首先建立统一的段寄存器、清屏并在文本模式显存中写入启动签名，随后通过 LBA 方式读取 Loader：

\codefile[firstline=5,lastline=48]{nasm}{../boot/mbr.asm}

关键步骤如下：

\begin{enumerate}
    \item 利用 BIOS 0x10 服务清空屏幕，为调试提供干净输出。
    \item 将 DS/ES/SS/FS 统一设置为 CS，保证对 \mintinline{text}{boot.inc} 常量的访问基址一致。
    \item 通过把 GS 指向 0xB800 文本显存，直接写入字符展示“KKKZBH”启动标识。
    \item 调用 \mintinline{text}{rd_disk_m_16}，以 0x02 扇区为起点读取 4 个扇区到 0x900——这正是 Loader 的驻留地址。
    \item 使用远跳转 \mintinline{text}{jmp LOADER_BASE_ADDR + 0x300} 转移到 Loader 的入口（0x900:0x300 = 0xC00 线性地址）。
\end{enumerate}

整个过程保持在 16 位实模式，目标只是把更复杂的 Loader 带入内存。

\section{16 位 LBA 读盘例程}

MBR 和 Loader 共用的 \mintinline{text}{rd_disk_m_16} 例程封装了 ATA 主通道的 PIO 读取流程。核心代码如下所示。

\codefile[firstline=50,lastline=103]{nasm}{../boot/mbr.asm}

要点包括：

\begin{itemize}
    \item 依次向 0x1F2--0x1F6 端口写入扇区数与 28 位 LBA 地址，再向 0x1F7 发送 0x20（READ SECTORS）命令。
    \item 轮询状态寄存器的 BUSY（bit7）与 DRQ（bit3）位，保证磁盘准备就绪。
    \item 以 \mintinline{text}{in ax, dx} 每次读取 2 字节数据，通过 \mintinline{text}{loop} 指令写入目标缓冲区。
\end{itemize}

该流程在保护模式阶段继续沿用：Loader 切换到 32 位寄存器后仍通过相同的端口序列完成磁盘读取。

\section{Loader：BIOS 内存探测}

Loader 起始于 0xC00，首先通过 BIOS \mintinline{text}{int 0x15} 的多种子功能探测可用物理内存，优先使用 E820 SMAP 接口，失败时回退至 E801/0x88：

\codefile[firstline=43,lastline=113]{nasm}{../boot/loader.asm}

结构体缓冲区 \mintinline{text}{ards_buf} 至少容纳 20 字节的 \mintinline{text}{Address Range Descriptor}，循环读取直到 BIOS 报告没有更多条目。若 E820 不可用，代码退化到老旧 BIOS 支持的 E801 或 AH=0x88，最终把得到的物理内存上界写入 \mintinline{text}{total_mem_bytes}。内存探测结果稍后会交给内核的物理页分配器使用。

\section{构建 GDT 并切换到保护模式}

内存探测完成后，Loader 需要完成三个同步动作：开启 A20 线、加载自制 GDT、设置 CR0 的 PE 位。相关代码如下所示：

\codefile[firstline=115,lastline=141]{nasm}{../boot/loader.asm}

值得注意的实现细节：

\begin{itemize}
    \item GDT 包含空描述符、代码段、数据段与显存段，并预留了额外的 60 个槽位，方便内核阶段继续扩展。
    \item 通过写入 0x92 端口打开 A20 线，确保物理地址 1MB 以上的访问不会回绕。
    \item 使用 \mintinline{text}{lgdt [gdt_ptr]} 装载 GDT，再把 \mintinline{text}{cr0} 的最低位（PE）设为 1，最后以远跳转刷新流水线进入 32 位环境。
\end{itemize}

此后代码区段采用 \mintinline{text}{bits 32} 指令，全部运行在保护模式下。

\section{搬运内核与建立分页}

进入保护模式后，Loader 的职责是把磁盘上的 \mintinline{text}{kernel.bin} 搬运到内存、解析 ELF Program Header，并为高半区内核准备分页结构：

\begin{enumerate}
    \item 使用 \mintinline{text}{rd_disk_m_32} 两次读取内核镜像，共 375 个扇区到 0x70000 起始的缓冲区。
    \item 调用 \mintinline{text}{kernel_init} 遍历 ELF Program Header，将各段复制到其期望的虚拟地址对应的物理位置。
    \item \mintinline{text}{setup_page} 在 1MB 处创建页目录与第一个页表：PDE[0] 与 PDE[768] 指向同一张页表，实现低端 4MB 的同址映射和内核高半区（0xC0000000）的镜像映射，并把最后一个 PDE 指向自身以便递归映射。
    \item 映射完成后，Loader 通过 \mintinline{text}{mov cr3, PAGE_DIR_TABLE_POS} 设置页目录基址，再把 \mintinline{text}{cr0} 的 PG 位置位，正式启用分页。
    \item 重新加载 GDT，并把 ESP 偏移 0xC0000000，使栈位于高半区，与未来内核的线性地址空间保持一致。
\end{enumerate}

\codefile[firstline=150,lastline=225]{nasm}{../boot/loader.asm}

分页初始化的细节如下所示：

\codefile[firstline=244,lastline=322]{nasm}{../boot/loader.asm}

最终，Loader 调用 \mintinline{text}{kernel_init} 完成镜像搬运，再把 ESP 调整到 0xC009F000，跳转至 \mintinline{text}{KERNEL_ENTRY_POINT}（0xC0001500），也就是 C/C++ 内核的入口点。引导阶段至此建立了分页、堆栈和段表，为下一章的内存管理模块提供稳定的基础。

