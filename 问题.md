# exec 执行用户程序时 Page Fault 问题

## 问题现象

执行用户程序 `/bin/a` 时发生 **Page Fault Exception**：
- 页错误地址为 `0x464C458F`（ELF 魔数的变形）
- CPU 尝试执行 ELF 文件头部字节，而不是程序的入口点

## 根本原因

**`file_read` 函数中使用 `malloc` 分配缓冲区，当在用户进程上下文（exec 期间）调用时，`malloc` 使用 USER 内存池，导致页表问题。**

### 详细分析

1. Shell fork 子进程后调用 `exec("/bin/a")`
2. `exec` → `load()` → `read()` → `file_read()`
3. `file_read` 调用 `malloc` 分配 `iobuf` 和 `all_blocks` 缓冲区
4. `malloc` 检测 `running_thread()->pgdir != nullptr`（用户进程），**使用 USER 内存池**
5. 这导致：
   - 缓冲区分配到**用户虚拟地址空间**（从 `0x8048000` 开始）
   - `malloc_page` 调用 `get_vaddr(USER, ...)` 从用户虚拟地址池获取地址
   - `page_table_add` 在用户页表中创建映射
6. 函数返回时 `free()` → `mfree_page()` 修改用户页表和虚拟地址 bitmap
7. 后续 `segment_load` 检查 PTE 或分配页面时，状态可能已被污染

### 测试验证

| 分配方式 | 结果 |
|---------|------|
| `std::vector`（使用 malloc） | ❌ Page Fault |
| `malloc/free` | ❌ Page Fault |
| 静态数组（内核 BSS 段） | ✅ 正常 |
| `get_kernel_pages`（内核池） | ✅ 正常 |

### 补充案例：sys_write (stdout) Page Fault

在修复 `file_read` 后，用户程序调用 `println` 再次触发 Page Fault。

**现象**：
- 用户程序可以执行简单的 `direct write syscall`。
- 但调用 `println` (内部调用 `sys_write` 输出到 stdout) 时 Crash。

**原因**：
- `sys_write` 处理 `stdout` 时也试图使用 `malloc(1024)` 分配临时缓冲区。
- 由于是在用户进程上下文中（系统调用期间），`malloc` 再次选择了 **USER 内存池**。
- `free()` 时 `mfree_page` 修改/清除了用户页表，可能破坏了用户栈或代码段的映射（取决于分配的具体地址），或者频繁的 PTE 修改导致了 TLB/缓存一致性问题。

**修复**：
- 同样改为使用 `get_kernel_pages` (KERNEL 池) 分配临时缓冲区。
- 这样内核的临时操作完全在内核空间进行，不干扰用户地址空间布局。

## 解决方案

### 临时方案（当前使用）


在 `file_read` 和 `sys_write` 中使用 `get_kernel_pages` 强制从内核内存池分配：

```cpp
// file.cpp & sysfunc.cpp
auto iobuf = (char*)get_kernel_pages(1);
// ... 使用 ...
mfree_page(pool_flags::KERNEL, iobuf, 1);
```

### 长期解决方案建议

1. **提供 `kmalloc/kfree`**：专门给内核代码使用的分配器，始终使用内核池
2. **修改 malloc 增加参数**：允许指定使用哪个内存池
3. **重新设计**：内核函数不应依赖当前线程的 `pgdir` 来决定内存池

## 相关文件


- `/kernel/module/filesystem/file.cpp` - `file_read` 函数
- `/kernel/module/filesystem/sysfunc.cpp` - `sys_write` 函数
- `/kernel/module/memory/alloc/malloc.cpp` - malloc 根据 pgdir 选择内存池
- `/kernel/module/memory/alloc/alloc.cpp` - `get_kernel_pages`, `mfree_page`
- `/kernel/module/user/exec.cpp` - exec 和 segment_load

## 参考

os-dev 参考书使用 `sys_malloc/sys_free`，同样区分内核和用户内存池，但由于 C 语言没有 RAII，内存释放时机更明确，可能未触发此问题。
